<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> jdk1.8 HashMap源码分析 · Mi Tang</title><meta name="description" content="jdk1.8 HashMap源码分析 - fish·nut"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://lpbobo.com/atom.xml" title="Mi Tang"></head><body><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/categories/Science" target="_self" class="nav-list-link">SCIENCE</a></li><li class="nav-list-item"><a href="/categories/Trip" target="_self" class="nav-list-link">TRIP</a></li><li class="nav-list-item"><a href="/About" target="_self" class="nav-list-link">WE</a></li></ul></header><div class="wrap"><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">jdk1.8 HashMap源码分析</h1><div class="post-info">2016年4月25日</div><div class="post-content"><p>根据jdk1.8的源码，分析HashMap底层实现机制，研究HashMap的数据结构的设计。</p>
<a id="more"></a>
<p><img src="http://7xlu9w.com1.z0.glb.clouddn.com/mitang_science_Hashmap.png" alt=""><br>本篇文章所有源码均来自jdk1.8版本，将在后续博客中与之前版本进行对比。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Hashmap类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> **<span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;** <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span>, <span class="title">Cloneable</span></span></div></pre></td></tr></table></figure>
<blockquote>
<p>AbstractMap缩减了HashMap需要实现的接口集合，Hashmap是可以序列化的，是可以拷贝复制的</p>
</blockquote>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>默认构造器，初始化bucket数目为16，负载因子为0.75：<code>Hashmap()</code></p>
<p>initCapacity表示bucket的数量，在预知key的数量时，能够有效避免扩容，提高性能：<code>Hashmap(int initCapacity)</code></p>
<p>loadFactor表示负载因子，衡量散列表的空间使用程度，用于平衡散列表的空间利用率和查找时间：<code>Hashmap(int initCapacity, float loadFactor)</code></p>
<p>前两种构造函数实际均调用第三种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>threshold</code>表示需要resize数组后的大小，值为大于initCapacity的最小的2^n（比如15对应的临界值为16），当数组的实际大小超过initCapacity时，将会扩容至threshold。</p>
<p>第四种构造函数为拷贝构造：<code>HashMap(Map&lt;? extends K, ? extends V&gt; m)</code></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>hashmap的底层基本数据结构是Node对象构成的数组，定义如下：<code>transient Node&lt;K,V&gt;[] table</code></p>
<p>其中Node是key-value的存储结构，并包含指向下一个Node节点的指针，从而当碰撞发生时构成一条链，基本定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">	...</div><div class="line">	Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K, V&gt; next) &#123;&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当链表长度超过8时，链表将转换为红黑树，其定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">	...</div><div class="line">	TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;&#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="关键源码分析"><a href="#关键源码分析" class="headerlink" title="关键源码分析"></a>关键源码分析</h2><ul>
<li>计算key的hash值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> h;</div><div class="line">	<span class="keyword">return</span> (k == <span class="keyword">null</span>) ? <span class="number">0</span>: (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>java中hashcode为32位，默认的table大小为16。为了能够将hashcode映射到table空间内，java采取了取hashcode的低位值做法<code>(table.length-1) &amp; hashcode</code>，那么就意味着hashcode的高位值在映射过程中不起作用，这很容易发生碰撞。因此，通过<code>&gt;&gt;&gt;16</code>将hashcode的高位与低位进行异或，合并高位与地位信息，使得映射均匀。</p>
</blockquote>
<ul>
<li>计算扩容大小：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">	n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">	n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">	n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">	n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">	n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">	<span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>tableSizeFor是一个求解大于cap的最小2^n算法，通过填充cap所有低位值为1，然后+1实现。</p>
</blockquote>
<ul>
<li>V put(K key, V value) </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">    	p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</div><div class="line">        	treeifyBin(tab, hash);</div><div class="line">     	<span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">    	<span class="keyword">break</span>;</div><div class="line">    p = e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>当binCount达到8时，表示需要通过<code>treeifyBin</code>将list转换成tree结构，以减少碰撞发生时的性能损失，提升查找速度。另外，判断一个key是否存在时需要两个条件：<strong>hashcode相同，key相同</strong>。</p>
</blockquote>
<h2 id="hashmap性能分析"><a href="#hashmap性能分析" class="headerlink" title="hashmap性能分析"></a>hashmap性能分析</h2><ol>
<li><p>hashmap中采用了大量的位运算加快计算速度</p>
</li>
<li><p>hashmap的table长度为2^n，使不同hash值发生碰撞的概率比较小，数据分布均匀，增加查询效率.</p>
</li>
<li><p>hashmap在最佳情况下的时间复杂度为O(1)，但是若发生碰撞，则需要遍历链表，那么最坏的时间复杂度就是O(n)，通过红黑二叉树对大量碰撞做优化，最坏的时间复杂度降为O(logn)</p>
</li>
<li><p>当hashmap需要扩容时，会重新映射已有的Node，是一个耗时操作，需要尽量避免。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.jianshu.com/p/e54047b2b563" target="_blank" rel="external">Hashmap的实现与优化</a></li>
</ol>
</div></article></div></section><footer><div class="paginator"><a href="/2016/04/26/金融自助领域的创新思路/" class="prev">上一篇</a><a href="/2016/04/21/高并发IO模型/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://lpbobo.com">fish·nut</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p><p><span>友情链接</span>&#58;&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="http://blog.csdn.net/sum__mer">sum__mer </a>&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="http://www.rudy-yuan.net">rudy-yuan </a>&nbsp;&nbsp;&nbsp;&nbsp;&bull;&nbsp;<a href="http://elvin.im">花花世界 </a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>